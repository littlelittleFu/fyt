// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FBSTRUCTS_H_
#define FLATBUFFERS_GENERATED_FBSTRUCTS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct Position;

struct AutoPickItem;
struct AutoPickItemBuilder;

struct DBElem;
struct DBElemBuilder;

struct UpdateTable;
struct UpdateTableBuilder;

struct UpdateTables;
struct UpdateTablesBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t x_;
  int16_t y_;

 public:
  Position()
      : x_(0),
        y_(0) {
  }
  Position(int16_t _x, int16_t _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  int16_t x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  int16_t y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 4);

struct AutoPickItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AutoPickItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_RADIUS = 6,
    VT_RELPOS = 8,
    VT_INTERVAL = 10
  };
  uint8_t mode() const {
    return GetField<uint8_t>(VT_MODE, 0);
  }
  uint8_t radius() const {
    return GetField<uint8_t>(VT_RADIUS, 0);
  }
  const ::flatbuffers::Vector<const Position *> *relpos() const {
    return GetPointer<const ::flatbuffers::Vector<const Position *> *>(VT_RELPOS);
  }
  uint16_t interval() const {
    return GetField<uint16_t>(VT_INTERVAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_RADIUS, 1) &&
           VerifyOffset(verifier, VT_RELPOS) &&
           verifier.VerifyVector(relpos()) &&
           VerifyField<uint16_t>(verifier, VT_INTERVAL, 2) &&
           verifier.EndTable();
  }
};

struct AutoPickItemBuilder {
  typedef AutoPickItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(uint8_t mode) {
    fbb_.AddElement<uint8_t>(AutoPickItem::VT_MODE, mode, 0);
  }
  void add_radius(uint8_t radius) {
    fbb_.AddElement<uint8_t>(AutoPickItem::VT_RADIUS, radius, 0);
  }
  void add_relpos(::flatbuffers::Offset<::flatbuffers::Vector<const Position *>> relpos) {
    fbb_.AddOffset(AutoPickItem::VT_RELPOS, relpos);
  }
  void add_interval(uint16_t interval) {
    fbb_.AddElement<uint16_t>(AutoPickItem::VT_INTERVAL, interval, 0);
  }
  explicit AutoPickItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AutoPickItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AutoPickItem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AutoPickItem> CreateAutoPickItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t mode = 0,
    uint8_t radius = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Position *>> relpos = 0,
    uint16_t interval = 0) {
  AutoPickItemBuilder builder_(_fbb);
  builder_.add_relpos(relpos);
  builder_.add_interval(interval);
  builder_.add_radius(radius);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AutoPickItem> CreateAutoPickItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t mode = 0,
    uint8_t radius = 0,
    const std::vector<Position> *relpos = nullptr,
    uint16_t interval = 0) {
  auto relpos__ = relpos ? _fbb.CreateVectorOfStructs<Position>(*relpos) : 0;
  return CreateAutoPickItem(
      _fbb,
      mode,
      radius,
      relpos__,
      interval);
}

struct DBElem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBElemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EID = 4,
    VT_DATA = 6
  };
  uint8_t eid() const {
    return GetField<uint8_t>(VT_EID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EID, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct DBElemBuilder {
  typedef DBElem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_eid(uint8_t eid) {
    fbb_.AddElement<uint8_t>(DBElem::VT_EID, eid, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(DBElem::VT_DATA, data);
  }
  explicit DBElemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBElem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBElem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBElem> CreateDBElem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t eid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  DBElemBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_eid(eid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBElem> CreateDBElemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t eid = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateDBElem(
      _fbb,
      eid,
      data__);
}

struct UpdateTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TID = 4,
    VT_KEY = 6,
    VT_ELEMS = 8
  };
  uint8_t tid() const {
    return GetField<uint8_t>(VT_TID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *key() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_KEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DBElem>> *elems() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DBElem>> *>(VT_ELEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TID, 1) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           VerifyOffset(verifier, VT_ELEMS) &&
           verifier.VerifyVector(elems()) &&
           verifier.VerifyVectorOfTables(elems()) &&
           verifier.EndTable();
  }
};

struct UpdateTableBuilder {
  typedef UpdateTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tid(uint8_t tid) {
    fbb_.AddElement<uint8_t>(UpdateTable::VT_TID, tid, 0);
  }
  void add_key(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> key) {
    fbb_.AddOffset(UpdateTable::VT_KEY, key);
  }
  void add_elems(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DBElem>>> elems) {
    fbb_.AddOffset(UpdateTable::VT_ELEMS, elems);
  }
  explicit UpdateTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateTable> CreateUpdateTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t tid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DBElem>>> elems = 0) {
  UpdateTableBuilder builder_(_fbb);
  builder_.add_elems(elems);
  builder_.add_key(key);
  builder_.add_tid(tid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UpdateTable> CreateUpdateTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t tid = 0,
    const std::vector<uint8_t> *key = nullptr,
    const std::vector<::flatbuffers::Offset<DBElem>> *elems = nullptr) {
  auto key__ = key ? _fbb.CreateVector<uint8_t>(*key) : 0;
  auto elems__ = elems ? _fbb.CreateVector<::flatbuffers::Offset<DBElem>>(*elems) : 0;
  return CreateUpdateTable(
      _fbb,
      tid,
      key__,
      elems__);
}

struct UpdateTables FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateTablesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<UpdateTable>> *tables() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<UpdateTable>> *>(VT_TABLES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.VerifyVector(tables()) &&
           verifier.VerifyVectorOfTables(tables()) &&
           verifier.EndTable();
  }
};

struct UpdateTablesBuilder {
  typedef UpdateTables Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tables(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UpdateTable>>> tables) {
    fbb_.AddOffset(UpdateTables::VT_TABLES, tables);
  }
  explicit UpdateTablesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateTables> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateTables>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateTables> CreateUpdateTables(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UpdateTable>>> tables = 0) {
  UpdateTablesBuilder builder_(_fbb);
  builder_.add_tables(tables);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UpdateTables> CreateUpdateTablesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<UpdateTable>> *tables = nullptr) {
  auto tables__ = tables ? _fbb.CreateVector<::flatbuffers::Offset<UpdateTable>>(*tables) : 0;
  return CreateUpdateTables(
      _fbb,
      tables__);
}

#endif  // FLATBUFFERS_GENERATED_A_H_
